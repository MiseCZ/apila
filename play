#!/usr/bin/env python

import yaml
import tasks
import sys
import argparse
import os
import subprocess

class color:
  PURPLE = '\033[95m'
  CYAN = '\033[96m'
  DARKCYAN = '\033[36m'
  BLUE = '\033[94m'
  GREEN = '\033[92m'
  YELLOW = '\033[93m'
  RED = '\033[91m'
  BOLD = '\033[1m'
  UNDERLINE = '\033[4m'
  END = '\033[0m'

def clear_todo():
  if os.path.exists('todo.yml'):
    os.unlink('todo.yml')

columns = int(subprocess.check_output(['tput', 'cols']))
parser = argparse.ArgumentParser(description='Setup AWS services by settings given by sequence of tasks.', formatter_class=lambda prog: argparse.HelpFormatter(prog, width=columns))
parser.add_argument('-d', '--doc', help='show known commands and exit', action='store_true')
parser.add_argument('--debug', help='on crash show backtrace', action='store_true')
parser.add_argument('--syntax-check', help='perform a syntax check on the playbook, but do not execute it', action='store_true')
parser.add_argument('-r', '--register', help='explicitly register event to do (can be used more times)', action='append', metavar='EVENT')
parser.add_argument('-u', '--unregister', help='explicitly unregister event to do loaded from todo.yml (can be used more times)', action='append', metavar='EVENT')
parser.add_argument('-t', '--tag', help='execute only tasks with specified tag (can be used more times)', action='append', metavar='TAG')
parser.add_argument('-e', '--exec', help='alternative filename to task.yml', metavar='file.yml', dest='entry_point')
parser.add_argument('path', help='path to folder with settings.')
args = parser.parse_args()

if args.doc:
  tasks.print_doc()
  sys.exit(0)

os.chdir(args.path)

tasks_filename = args.entry_point if args.entry_point else 'tasks.yml'

print "Processing content of %s executing %s ..." % (os.getcwd(), tasks_filename)

config = yaml.load(open('config.yml').read())

for tag, constructor in tasks.get_yaml_tags_constructors(config).iteritems():
  yaml.add_constructor(tag, constructor)

receipt = yaml.load(open(tasks_filename).read())

task_list = [tasks.create_task(task_def, config) for task_def in receipt]

errors = []
for task in task_list:
  task.validate(errors)

if len(errors) > 0:
  print 'Script contains some error:\n  %s' % '\n  '.join(errors)
  sys.exit(1)

if args.syntax_check:
  print 'Syntax of %d tasks ok.' % len(task_list)
  sys.exit(0)

cache = tasks.Cache()
clients = tasks.Clients()

if os.path.exists('todo.yml'):
  todo = set(yaml.load(open('todo.yml').read()))
  print "Events restored from todo.yml:", ', '.join(map(lambda x: "'%s'" % x, todo))
else:
  todo = set()

if args.register:
  todo.update(args.register)
if args.unregister:
  todo.difference_update(args.unregister)

registered = todo
tags = args.tag

def task_run(clients, cache, debug):
  if debug:
    return task.run(clients, cache)
  else:
    try:
      out = task.run(clients, cache)
    except Exception as e:
      out = (False, str(e))
    return out

for task in task_list:
  print '...', ' '*15, unicode(task).encode('utf8'), ' ',
  if (not task.when or task.when.intersection(registered)) and (not tags or (task.tags and task.tags.intersection(tags))):
    (ok, message) = task_run(clients, cache, args.debug)
    if ok:
      if message:
        if task.register:
          registered.update(task.register)
        print '\r%ssuccess (%s)%s' % (color.BLUE + color.BOLD, message, color.END)
      else:
        print '\r%ssuccess%s' % (color.GREEN + color.BOLD, color.END)
    else:
      print '\r%sfailed\njob failed with message "%s"!%s' % (color.RED + color.BOLD, message, color.END)
      if registered:
        open('todo.yml', 'w').write('# registered events after last fail\n'+yaml.dump(list(registered)))
      else:
        clear_todo()
      sys.exit(1)
  else:
    print '\r%sskipped%s' % (color.YELLOW + color.BOLD, color.END)

clear_todo()
