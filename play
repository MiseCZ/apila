#!/usr/bin/env python
"""
Tool execute sequence of task loaded from file at target path (default tasks.yml).
Sample script you can see in demo/tasks.yml.
One task can look like this:
- name: Create something for any reason
  <task>:
    task_param: 'some value'
  tags:
    - tagname
  register:
    - throwed event
  when:
    - needed event
or ofcourse in json syntax (is compatible wit yaml):
[
    {
        "name": "Create something for any reason",
        "<task>": {
            "task_param": "some value"
        },
        "register": [
            "throwed event"
        ],
        "when": [
            "needed event"
        ],
        "tags": [
            "tagname"
        ]
    }
]
attribute name is used for desribe what and why task is doing (is optional, when missing, task try create own message)
attribute <task> is action defined what task do and his own parameters (see list of known tasks bellow)
attribute register is a list of events to do if task end with result "created" or "changed"
attribute when is a list of events conditioning execution of task - if is before registered one of this events, task is executed
attribute tags is a list of ids allowing filtering tasks to execute - if you set some tag at command line, only tasks containing this tag are executed
"""
__version__ = '0.8.10'

import yaml
import tasks
import sys
import argparse
import os
import subprocess
import tasks.task_runner
import logging

class DocAction(argparse.Action):
  def __init__(self, option_strings, dest=argparse.SUPPRESS, help=""):
      super(DocAction, self).__init__(option_strings=option_strings, dest=dest, default=argparse.SUPPRESS, nargs=0, help=help)

  def __call__(self, parser, namespace, values, option_string=None):
    print __doc__
    tasks.print_doc()
    parser.exit()

columns = int(subprocess.check_output(['tput', 'cols']))
parser = argparse.ArgumentParser(description='Setup AWS services by settings given by sequence of tasks.', formatter_class=lambda prog: argparse.HelpFormatter(prog, width=columns))
parser.add_argument('-V', '--version', action='version', version='%(prog)s '+__version__)
parser.add_argument('--doc', help='show known commands and exit', action=DocAction)
parser.add_argument('--debug', help='on crash show backtrace', action='store_true')
parser.add_argument('--syntax-check', help='perform a syntax check on the playbook, but do not execute it', action='store_true')
parser.add_argument('-r', '--register', help='explicitly register event to do (can be used more times)', action='append', metavar='EVENT')
parser.add_argument('-u', '--unregister', help='explicitly unregister event to do loaded from todo.yml (can be used more times)', action='append', metavar='EVENT')
parser.add_argument('-t', '--tag', help='execute only tasks with specified tag (can be used more times)', action='append', metavar='TAG')
parser.add_argument('-e', '--exec', help='alternative filename to task.yml', metavar='file.yml', dest='entry_point')
parser.add_argument('-c', '--conf', help='alternative filename to config.yml', metavar='file.yml')
parser.add_argument('path', help='path to folder with settings.')
args = parser.parse_args()

logging.basicConfig(level=(logging.ERROR if args.debug else logging.CRITICAL))

os.chdir(args.path)

tasks_filename = args.entry_point if args.entry_point else 'tasks.yml'
default_conf_filename = 'config.yml'

print "Processing content of %s executing %s ..." % (os.getcwd(), tasks_filename)

conf_filename = args.conf if args.conf else default_conf_filename

if conf_filename != default_conf_filename:
  print "Using alternative config %s ..." % conf_filename

with open(conf_filename) as conf_file:
  config = yaml.load(conf_file.read())

for tag, constructor in tasks.get_yaml_tags_constructors(config).iteritems():
  yaml.add_constructor(tag, constructor)

with open(tasks_filename) as tasks_file:
  receipt = yaml.load(tasks_file.read())

task_list = [tasks.create_task(task_def, config) for task_def in receipt]

errors = []
for task in task_list:
  task.validate(errors)

if len(errors) > 0:
  print 'Script contains some error:\n  %s' % '\n  '.join(errors)
  sys.exit(1)

if args.syntax_check:
  print 'Syntax of %d tasks ok.' % len(task_list)
  sys.exit(0)

cache = tasks.Cache()
clients = tasks.Clients()

if os.path.exists('todo.yml'):
  todo = set(yaml.load(open('todo.yml').read()))
  print "Events restored from todo.yml:", ', '.join(map(lambda x: "'%s'" % x, todo))
else:
  todo = set()

if args.register:
  todo.update(args.register)
if args.unregister:
  todo.difference_update(args.unregister)

registered = todo
tags = args.tag

tasks.task_runner.run_tasks(task_list, clients, cache, registered, tags)

tasks.task_runner.clear_todo()
